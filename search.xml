<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[项目]]></title>
    <url>%2F2019%2F03%2F06%2F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[DevOps工具链DevOps 通过高度自动化工具与流程来使得软件构建、测试、发布更加快捷、频繁和可靠 将开发、运维一体化 可以把 DevOps 看作开发（软件工程）、技术运营和质量保障（QA）三者的交集。 传统的软件组织将开发、IT 运营和质量保障设为各自分离的部门， 按照从前的工作方式，开发和部署，不需要 IT 支持或者 QA 深入的跨部门的支持；而现在却需要极其紧密的多部门协作。 而 DevOps 考虑的还不止是软件部署，它是一套针对这几个部门间沟通与协作问题的流程和方法。 好处 代码的提交直接触发：消除等待时间，快速反馈 每个变化对应一个交付管道：使问题定位和调试变得简单 全开发流程高效自动化：稳定，快速，交付结果可预测 持续进行自动化回归测试：提升交付质量 持续集成 频繁地（一天多次）将代码集成到主干 让产品可以快速迭代，同时还能保持高质量 持续交付 频繁地将软件的新版本，交付给质量团队或者用户，以供评审。 持续部署 持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 工具链 代码托管：gitlab 为什么不使用github？ gitlab对仓库有更多的控制，可以设置仓库权限是公用的还是私有的 每一次的提交或者 Merge Request 的合并都可以触发pipeline 持续集成 gitlabCI：集成较好， 界面美观优雅， 使用简单 gitlab runner进行构建任务 pipeline：相当于一次构建任务，里面可以包含多个流程，比如自动构建、自动进行单元测试、自动进行代码检查等流程 stages： build, test, deploy jobs 包含实时构建日志，容易追踪 Jenkins 通过gitlab的webhook设置，自动触发构建工作，就不需要人工干预了 jenkins在项目配置时可以配置远程构建触发器，设置好jenkins的回调url后就可以让jenkins进行自动构建。 jenkins将代码打成docker镜像，push到docker-registry 静态代码检查：sonarqube Sonar GitLab Plugin 插件 该插件会针对每次提交修改的文件，添加注释行，同时添加本次提交的代码检测结果的评论 配合 gitlab-ci 完成每次 commit 时，添加的代码检测 Pipelines stage 流程，来控制代码检测流程是否通过 检查范围： 不遵循代码标准 重复 潜在的缺陷 质量糟糕的复杂度分布 注释不足或过多 缺乏单元测试 糟糕的设计 PMD,checkstyle，findbugs等代码规则检测工具规范代码编写/检测出潜在的缺陷 可以很方便地统计并展示单元测试覆盖率 项目部署：docker 使用GitLab runner 来 build docker image上传到仓库中 为了要让 runner 可以调用 docker 命令, 需要把 gitlab-runner 这个用户加入 docker 所在组. MyBatis MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 优点 简单易学：没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件 灵活：不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。 解除sql与程序代码的耦合，提高了可维护性 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 缺点 编写SQL语句时工作量很大，尤其是字段多、关联表多时。 SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。 框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 二级缓存机制不佳 原理 应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。 教育平台SpringIoC 控制反转是一种通过描述并通过第三方去产生或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是DI（依赖注入） 解决了类与类之间的依赖关系。程序员将控制类与类之间依赖的权利交给了IOC 比如说我们现在有两个类A和B，那么我们不需要new A()、或者new B()来创建A和B的对象，Spring会帮我们创建A和B的对象（默认是单例），并且把A和B的对象放入IoC容器中，如果B对象中需要用到A对象的话，那么就要用到DI，Spring会帮我们把A对象注入到B对象中，一般是通过setter方法注入或构造器注入。 在Spring中，有两个主要的IoC容器系列 实现BeanFactory接口的简单容器系列 实现ApplicationContext接口的高级容器系列 在解析元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。 IoC容器的初始化： BeanDefinition的Resource定位：BeanDefinition的资源定位。 BeanDefinition的载入：把用户定义好的Bean表示成IoC容器内部的数据结构，即BeanDefinition。 BeanDefinition的注册：把BeanDefinition向IoC容器注册。 依赖注入的过程是用户第一次向IoC容器索要Bean时触发的，在BeanFatory接口中的getBean方法的实现就是触发依赖注入的地方。 Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖AOP spring AOP的底层实现是动态代理 提供了对JDK动态代理的支持以及CGLib的支持。 JDK动态代理只能为接口创建动态代理实例，而不能对类创建动态代理 CGLib动态代理需要依赖asm包，把被代理对象类的class文件加载进来，修改其字节码生成子类。 AspectJ的底层技术是静态代理 通过一个命令来编译，生成一个新的代理类 在编译时增强 Spring MVC工作原理 Http请求：客户端请求提交到前置控制器DispatcherServlet DispatcherServlet寻找处理器Controller：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求所对应的Controller 处理器Controller执行：DispatcherServlet将请求提交到Controller，Controller调用业务逻辑处理后，返回ModelAndView。 dispatcherServlet借助ViewResoler完成逻辑视图到真实视图对象的解析 dispatcherServlet使用这个view对ModelAndView中的模型数据进行视图渲染，返回给用户 Spring Boot 主要是简化了spring的难度，简省了繁重的配置，提供了各种容器，开发者能快速上手 优点 独立运行 内嵌了各种servlet容器，Tomcat、Jetty等 不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。 简化配置 spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置 自动配置 Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。 无代码生成和XML配置 Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的 应用监控 Spring Boot提供一系列端点可以监控服务及应用，做健康检测。 核心注解 @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项 @ComponentScan：Spring组件扫描 如何理解 Spring Boot 中的 Starters Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。 hibernate Hibernate是开源的一个ORM（对象关系映射）框架，是对JDBC的进一步封装 核心：面向对象、关系映射以及数据持久化 优点 更加对象化：只需要操作对象就可以 移植性：做了持久层的封装，所写代码都具有可复用性 没有侵入性(轻量级)：Hibernate不需要继承任何类，不需要实现任何接口。这样的对象叫POJO对象。 代码测试方便 提高效率，提高生产力 缺点 使用数据库特性的语句，将很难调优 对大批量数据更新存在问题 系统中存在大量的攻击查询功能 hibernate与mybatis的对比 Hibernate的真正掌握要比Mybatis困难，Hibernate比mybatis更加重量级一些。 Mybatis需要手动编写SQL语句，Hibernate也可以自己写SQL语句来指定需要查询的字段，但这样破坏了Hibernate封装以及简洁性。 mybatis由于所有SQL都是依赖数据库书写，所以扩展性，迁移性比较差 hibernate有更好的二级缓存机制，可以使用第三方缓存，MyBatis本身提供的缓存机制不佳 总结： 对于数据的操作，hibernate是面向对象的，而MyBatis是面向关系的。 Mybatis：小巧、方便、高效、简单、直接、半自动化 Hibernate：强大、方便、高效、复杂、间接、全自动化 JPA Spring Data JPA是Spring Data的子模块。使用Spring Data，使得基于”repositories”概念的JPA实现更简单和容易。 JPA默认使用hibernate作为ORM实现，所以，一般使用Spring Data JPA即会使用hibernate。 题库系统 判题程序在docker中进行，启动容器安装java环境，将容器保存为镜像 限制程序的运行资源，如内存、时间用量，进程、线程数量 对于每组测试数据，将输入数据写为工作目录的文本文件后，在子进程中限制资源，用freopen重定向输入输出，并使用execl运行程序，在父进程中使用ptrace监听控制子进程。这里有个坑，就是Docker默认是不能使用ptrace的，因此要在启动容器的时候加上启动选项 –cap-add=SYS_PTRACE。 https://zhuanlan.zhihu.com/p/27807692 dubbo/zookeeperdubbo 分布式服务框架，使用RPC调用 zookeeper 高可用的分布式管理与协调框架 树型的目录服务的数据存储 应用场景 配置管理 集群管理：leader选举，集群容错 发布与订阅 数据库切换 分布式日志的收集]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Redis key-value类型的内存(缓存)数据库 整个数据库加载到内存中操作，定期flush到硬盘上进行保存 单线程 集群是master/slave模式 与memchached的区别 memchached仅支持string类型，Redis支持更丰富的数据类型 Redis速度更快 Redis可以持久化 支持的数据类型和底层实现 在Redis中，所有key-value对都存储在一个hash table中 Hash table是一个二维结构 一个一维固定长度的数组，每个槽位上保存一个dictEntry对象。key计算hash值后按照这个定长数组求模，结果相同的key-balue通过链表保存在同一个槽位上，这样便形成了一个二维结构 String 能存为整数则存为整数，不能则存为原始字符串 List 使用 zip List结构 zip list通过一个连续的内存块实现list结构，其中的每个entry节点头部保存前后节点长度信息，实现双向链表功能 当list内容较多时，使用双向链表 hash 新建的Hash类型也使用zip list存储value 保存数据过多时，转而使用hash table set 创如果value能够表示为整数，则使用intset类型保存value。intset使用和ziplist相似的实现方式保存整数 数据量大时，切换为使用hash table 使用场景 会话缓存 队列 发布/订阅 排行榜/计数器 如何做内存优化？ 使用hashes(散列表) Redis是单线程，如何提高CPU利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用 MySQL存储引擎https://draveness.me/mysql-innodb InnoDB 所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page） 页作为磁盘管理的最小单位,在页中数据按行存储。 MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储 B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，然后数据库把整个页读入到内存中，并在内存中查找具体的数据行。 聚集索引 存放着一条行记录的全部信息 辅助索引 只包含索引列和一个用于查找对应行记录的『书签』。 InnoDB与MYlSAM区别两者都是MySQL中最常用的两个表类型 MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快 InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁，所以MyISAM往往就容易被人认为只适合在小项目中使用,但是如果项目要求99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选 索引 索引 原理 对要查询的字段建立索引其实就是把该字段按照一定的方式排序；建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效了 优点 加快数据检索速度，提高对数据访问效率 提高数据查询性能 缺点 占用大量硬盘空间 数据的增删改等更新操作，需要维护索引时间，降低更新速度 适用场合 主键列中创建索引 多表连接时连接列创建索引 where子句查询的列 需要经常GROUP BY和ORDER BY的列 类型 主键索引 普通索引/单列索引 多列索引/复合索引 使用复合索引时遵循最左前缀原则 最左前缀原则 最左优先，先要看第一列，在第一列满足的条件下再看左边第二列，以此类推 eg: 多列字段做索引，state/city/zipCode，想要索引生效的话，只能使用如下的组合：state/city/zipCode，state/city，state。其他方式（如city，city/zipCode），则索引不会生效 MySQL索引 B+树 特点 非叶子节点的子树指针与关键字个数相同 非叶子节点不存储数据，只存储指针索引(洗漱索引)；叶子节点存储所有关键字数据(稠密索引)，不存储指针 在经典B+树基础上增加了顺序访问指针，每个叶子节点都有指向相邻下一个叶子节点的指针 提高区间访问的性能 更适合文件系统 为什么说B+树比B树更适合数据库索引？ B+树的磁盘读写代价更低 B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了 B+树的查询效率更加稳定 任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 方便扫库 由于B+树的数据都存储在叶子结点中，分支结点均为索引，只需要扫一遍叶子结点即可 范围扫描更简单 内部节点可以定位更多叶子节点 SQL优化 重写order by语句以使用索引 SELECT子句中避免使用 ‘ * ‘ 减少访问数据库的次数 用Where子句替换HAVING子句/order by 通过内部函数提高SQL效率 用EXISTS替代IN、用NOT EXISTS替代NOT IN 使用索引 避免在索引列上使用NOT 避免在索引列上使用计算 事务 概念 指访问并可能更新数据库中各种数据项的一个程序执行单元 对数据库进行读或写的一个操作序列 特性 原子性(A):事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性(C):事务应确保数据库的状态从一个一致状态转变为另一个一致状态。 隔离性(I):一个事务的执行不应影响其他事务的执行 持久性(D):一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 事务隔离级别 脏读 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 不可重复读 指在一个事务内，多次读同一数据。两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的 幻读 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。 级别 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 四级封锁协议：其他事务不能 读写 该表中的任何数据 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放 Read committed (读已提交)：可避免脏读的发生。 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁 （瞬间S锁）。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 锁(InnoDB) 种类 排他锁/写锁/x锁 事务T可以修改A也可以读A，其他事务不能再对A加任何锁，直到事务T释放A上的锁 共享锁/读锁/s锁 其他事务可以读A，而在事务T释放A上的S锁之前不能对A进行修改 现象 死锁 互相等待 形成条件 互斥：排它性 请求和保持：对自己已获得的其它资源保持不释放 不剥夺：不能被剥夺，只能在使用完时由自己释放 循环等待 预防和解除 预防：破坏四个条件之一 避免：银行家算法 解除 剥夺资源 活锁 某一个事务T可能饿死(永远等待) 避免活锁的简单方法是采用先来先服务的策略。 并发控制机制 乐观锁：是一种思想 会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁 悲观锁：是一种锁 在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源 乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题 锁的算法 记录锁(record lock):加到索引记录上的锁 间隙锁(gap lock):对索引记录中的一段连续区域的锁 当使用类似 SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE; 的 SQL 语句时，就会阻止其他事务向表中插入 id = 15 的记录，因为整个范围都被间隙锁锁定了 间隙锁是存储引擎对于性能和并发做出的权衡，并且只用于某些事务隔离级别 虽然间隙锁中也分为共享锁和互斥锁，不过它们之间并不是互斥的，也就是不同的事务可以同时持有一段相同范围的共享锁和互斥锁，它唯一阻止的就是其他事务向这个范围中添加新的记录 Next-key lock:是前两者的结合 Next-Key 锁锁定的是当前值和前面的范围。 当我们更新一条记录，比如 SELECT * FROM users WHERE age = 30 FOR UPDATE;，InnoDB 不仅会在范围(21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。 解决幻读的问题 分布式事务https://zhuanlan.zhihu.com/p/41725894 CAP定理 一致性(Consistence):等同于所有节点访问同一份最新的数据副本 可用性(Availability):每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据 分区容错性(Partition tolerance):以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择 分布式系统只能满足三项中的两项而不可能满足全部三项 BASE理论 基本可用(BasicallyAvailable):分布式系统在出现不可预知故障的时候，允许损失部分可用性 响应时间上的损失 功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。 软状态(Softstate):允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不到的过程存在延时。 最终一致性(Eventuallyconsistent):需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性 分布式解决方案 二阶段提交（2PC） 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作 补偿事务（TCC） 针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作 降低锁冲突、提高吞吐量成。 与2PC相比实现以及流程相对简单了一些 会造成代码量庞大，耦合性高 有局限性，因为有很多的业务是无法很简单的实现回滚的 本地消息表 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。 消息队列 消息队列 优点 解耦： 将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改 异步： 将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快相应速度(邮件和验证码) 流量削锋： 系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的 缓冲 缺点 系统可用性降低 系统复杂性增加：考虑一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等 类型 ActiveMQ：主从 RabbitMQ：主从 RocketMQ：分布式 Kafka：分布式发布-订阅系统 如何保证消息队列是高可用的？ Kafka为例 一个topic分为多个partition，每个partition有多个副本，消息存储在 Broker的某一Topic的某一Partition中，同时存在多个副本 leader选举，选举的partition leader负责读写，其他的副本作为follower从leader同步消息 如何保证消息不被重复消费？ 造成重复消费的原因：因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 针对业务场景 eg:拿到这个消息做数据库的insert操作，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。 eg：拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作 如何保证消息的可靠性传输？ 生产者丢数据：RabbitMQ提供transaction和confirm模式来确保生产者不丢消息 发送消息前开启事务，然后发送，出现异常则回滚，成功则提交事务 消息队列丢数据：持久化磁盘 消费者丢数据：手动确认消息(RabbitMQ会自动确认消息然后删除) 如何保证消息的消费顺序？ 通过算法将需要保持先后顺序的消息放到同一个消息队列中，然后只用一个消费者去消费该队列 保证入队有序就行，出队以后的顺序交给消费者自己去保证 SQL注入 通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F02%2F28%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程创建线程 继Thread类 实现Runnable接口 实现Callable接口(比runnable多一个返回值) Java不支持多继承，但可以实现多个接口。 start()方法会启动一个新线程，并包含run()方法。而run()只会执行run方法，不会启动新线程 线程池 为什么要用线程池？ 降低消耗。降低创建和销毁线程造成的消耗 提高响应速度。任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性 参数 corePoolSize：线程池核心线程数量 如果池中线程数量少于核心线程池数量，则直接新建线程处理当前任务 当池中无空闲线程时，新任务将被添加到阻塞队列 核心线程池空闲不会被回收。 maximumPoolSize：线程池最大线程数量 当阻塞队列已满，并且有新任务还在入队时，创建新的线程处理，直到线程数大于maximumPoolSize 超出corePoolSize部分的线程超过空闲时间后会被回收 当线程已经超出maximumPoolSize，并且阻塞队列已满，则通过handler所指定的策略来处理任务。 keepAliveTime：线程存活时间 当线程超出corePoolSize时生效 workQueue：阻塞队列（存储等待执行的任务） threadFactory：线程工厂，用来创建线程 ThreadLocal 用于线程间的数据隔离 使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本 Wait/Notify/NotifyAll wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类 why？ wait():线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。 notify():唤醒一个正在等待该锁的对象 notifyAll():唤醒所有等待该锁的对象，但这些对象会竞争，只有一个获得该锁 synchronized关键字使用方式： 修饰实例方法，对当前实例加锁，进入同步代码之前需要获得当前实例的锁 修饰静态方法，对当前类对象加锁，进入同步代码之前需要获得当前类对象的锁。 修饰代码块，对指定对象加锁，进入同步代码之前需要获得指定对象的锁。与LOCK的区别 对于synchronized,如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。Lock可以提高多个线程进行读操作的效率 Lock可以知道线程有没有成功获取到锁。synchronized不行 采用synchronized不需要用户去手动释放锁，而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； Lock可以让等待锁的线程响应中断，而synchronized却不行 synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略 ReenTrantLock 与synchronized一样都可重入，同一线程可以多次获得同一个锁 实现了Lock接口 ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。 volatile作用： JVM提供的最轻量级的同步机制 一个变量使用volatile之后，具备两种特性： 保证此变量对所有线程的可见性 符合以下两条规则才能保证原子性： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中。 禁止指令重排序优化 eg: //1 volatile boolean shutdownRequested; public void shutdown() { shutdownRequested = true; } public void doWork() { while (!shutdownRequested) { //do stuff } } //2 public class ChessyCounter{ @GuardedBy(&quot;this&quot;) private volatile int value; //读操作，没有synchronized，提高性能 public int getValue(){ return value } //写操作，必须synchronized。因为x++不是原子操作 public synchronized int increment() { return value++; } } //锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作 //使用锁进行所有变化的操作，使用 volatile 进行只读操作。 与synchronized区别： synchronized关键字解决的是执行控制的问题，volatile关键字解决的是内存可见性的问题 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进程/线程1. 进程线程区别与联系 区别： 进程是资源分配的最小单位；线程是CPU调度的最小单位 进程切换消耗资源更大 线程的划分尺度小于进程，导致多线程并发性更高 线程拥有自己独立的栈和栈指针等信息 多线程程序的并发性高 联系： 一个程序至少有一个进程，一个进程至少有一个线程 进程在执行过程中拥有独立的内存单元，而多个线程共享所在进程的内存 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。2. 进程间通信方式 管道：半双工，是数据只能单向流动 无名管道：只能在具有亲缘关系的进程间使用，一般指父子 有名管道：允许无亲缘关系进程间的通信。 缓冲区有限 只能承载无格式字节流 信号量 消息队列 可以实现任意进程间的通信，通过系统调用函数 来实现消息发送和接收之间的同步，无需考虑同步问题，方便 信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合 共享内存 套接字：可用于不同机器间的进程通信，用socket实现 3. 线程间通信方式 锁 信号量semaphore：同一时刻访问此资源的最大线程数量 信号signal：通过通知操作的方式来保持多线程同步 4. 进程的几种状态 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数 阻塞状态： 进程等待某种条件，在条件满足之前无法执 就绪→执行；执行→就绪；执行→阻塞；阻塞→就绪 5. 进程调度策略 FCFS先来先服务：没有考虑优先级 短作业优先：不利于长作业 高响应比优先：响应比计算系统开销，增加系统开销 时间片轮转 多级反馈队列 6. 进程同步机制 信号量 管程 内存1. 段页区别 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。 段的大小不固定，有它所完成的功能决定 页的大小固定，由系统决定. 段向用户提供二维地址空间，在标识一个地址时，即需给出段名，又需给出段内地址 页向用户提供的是一维地址空间 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制 页式虚拟存储系统存在内部碎片；段式虚拟存储系统，存在外部碎片]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[HTTP(无状态的协议)/HTTPS1. 两者区别？ HTTP是不安全的，HTTPS是安全的 OSI模型中，HTTP在应用层，HTTPS的安全传输机制在传输层 HTTP无法加密，HTTPS对传输的数据进行加密 HTTP不用证书，而HTTPS需要CA机构颁发的SSL证书 HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+消息完整性保护 2. HTTPS工作原理 双向认证 SSL 协议的具体通讯过程，服务器和用户双方必须都有证书 客户端发起HTTPS请求，服务器返回自己的证书、对称加密算法种类等信息 客户端判断服务器的CA证书是否由信任的CA中心签发，是则验证证书中的信息，不是则询问是否继续访问 客户端发送客户端证书，服务器进行相同的身份认证 服务器选择一种加密方案，使用客户端公钥加密后通知客户端 客户端通过私钥解密后得知服务器选择的加密方案，选择一个通话秘钥key，用服务器公钥加密后发给服务器 服务器收到后用私钥解密，获得通话秘钥key 接下来的数据传输都用该对称秘钥key进行加密 通过非对称秘钥机制保证双方身份认证，完成建立连接，在实际数据通信中通过对称秘钥机制保障数据安全性 3. GET与POST方法的区别？ GET重点在从服务器获取资源，POST重点在向服务器发送数据 get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin 这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的； POST比GET更安全 RESTful架构 特点 用URL描述资源 使用HTTP方法描述行为。使用HTTP状态码来表示不同的结果 使用json交互数据 是一种风格 面向资源 TCP / UDP（传输层）1. TCP三次握手过程 主机A发送SYN包(同步序列号)到服务器 (SYN_SENT)，等待B确认 B收到后确认A的SYN (SYN_RCVD)，同时自己也发送一个SYN+ACK包 (ESTABLISHED) A收到SYN+ACK包后，向B发送ACK包 (ESTABLISHED)。完成三次握手，开始传输数据 三次握手特点：没有应用层的数据 2. TCP关闭：四次握手 A将FIN控制位置为1 (FIN_WAIT_1)，提出停止TCP的请求 (CLOSE_WAIT) B收到后对其作出响应，将ACK置为1 B将FIN置为1 (FIN_WAIT_2)，提出反方向的关闭请求 (LAST_ACK) A对B的请求进行确认 (TIME_WAIT)，将ACK置为1 (CLOSED) TIME_WAIT 状态是在服务端发送FIN，客户回复ACK后,为什么需要2MSL时间(报文最大生存时间)？ 为了保证最后一个ACK因丢失，而等待重发的时间 保证残留网络报不会被新连接接收而产生数据错乱。保证所有残留的网络报在自己关闭前都已经超时 3. TCP头部 16位 源端口 16位 目标端口 32位 序列号 32位 确认号 4位 头部长度：指示何处数据开始 16位 窗口大小 16位 校验和 16位 紧急指针 4. TCP如何保证可靠性传输 将数据截成合理长度 超时重发 推迟验证(对于收到的请求会给出确认响应，响应前会进行完整校验) 如果收到的检验和有差错，TCP将丢弃这个报文，并且不确认收到此报文段。然后发送数据端会超时重发 对失序数据进行重排序 丢弃重复数据 流量控制 TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。 5.TCP粘包问题 粘包问题：发送方发送的若干包数据到接收方接收时粘成一包，从缓冲区来看，后一包的头紧接着前一包数据的尾 可能发生的场景：需要在连接后一段时间内发送不同结构数据 出现原因 发送端需要等缓冲区满才发送出去，造成粘包 接收方不及时接收缓冲区的包，造成多个包接收 不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。 解决措施： 对于发送方引起的粘包：编程设置，使用TCP强制数据立即传送的指令（但是关闭了优化算法） 对于接收方引起的粘包：优化程序设计，提高接收进程优先级等（但是无法完全避免粘包现象） 由接收方控制，将一包数据按结构字段，人为控制分多次接收然后合并（效率极低） nagle算法 为了尽可能发送大块数据,避免网络中充斥着许多小数据块。 将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包 6. TCP流量控制/拥塞控制 流量控制：滑动窗口 让发送方的发送速率不要太快，要让接收方来得及接收 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载 拥塞：对资源的需求超过了可用资源，造成网络性能降低 慢开始：由小到大逐渐增大拥塞窗口数值(发送方的发送窗口=拥塞窗口) 拥塞避免算法：比慢开始算法的拥塞窗口增长速率缓慢 一旦出现拥塞，将窗口大小立即置为1，执行慢开始算法 快重传和快恢复 接收方每收到一个失序的报文段后就立即发出重复确认 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等重传计时器到期 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限减半，把拥塞窗口设置为慢开始门限减半后的数值，并执行拥塞避免算法 7. TCP和UDP区别 面向连接与无连接 对系统资源的要求(TCP较多，UDP少) 面向字节流和面向报文 TCP提供流量控制/拥塞控制，UDP无拥塞控制 TCP仅支持一对一 TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证 UDP适应于对实时要求较高、不允许有较大时延的情况，如航空信息应用。 RPC框架（dubbo） 像调用本地的函数一样去调远程函数，基于TCP 面向过程 DNS1. 从输入URL到页面加载发生了什么？ DNS解析： 浏览器缓存 → 系统缓存 → 路由器缓存 → ISP DNS缓存 → 递归搜索( . -&gt; .com -&gt; google.com. -&gt; www.google.com.。) TCP连接 发送http请求，服务器返回一个重定向地址 浏览器跟踪重定向地址 服务器处理http请求并返回http报文 浏览器解析、渲染页面 Session / Cookie Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中 服务器在创建了Session的同时，会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式 第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器 常见应用场景：自动登录 安全性较低，以明文形式存放在浏览器中 cookie增多会增加网络带宽，session增多会占用服务器性能 cookie被禁用？ URL重写 每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM整理]]></title>
    <url>%2F2019%2F01%2F19%2FJVM%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[JVM运行内存的分类 程序计数器 线程私有 当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址 如果正在执行的是native方法，则为空 虚拟机栈 线程私有 每个方法被执行的时候都会同时创建一个栈帧用于存放局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 生命周期与线程相同 为java方法服务 native方法栈 与java虚拟机栈相似 区别：为native方法服务 java堆 线程共享 JVM所管理的内存中最大的一块，在虚拟机启动时创建 唯一目的：存放对象实例、数组 GC回收的主要区域 方法区 线程共享 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 回收目标：主要是常量池的回收和类型的卸载 Java四大引用 强引用 如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题 例子：Object obj = new Object(); 这里obj 就是引用，new Object() 对象实例存储在堆内存，obj引用的是对象实例的内存地址。 软引用 可以和一个引用队列（ReferenceQueue) 联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中 用来描述可用但不是必须存活的对象；在内存溢出之前，虚拟机尝试对这些对象进行回收。如果回收之后内存还是不够才会出现内存溢出情况。 弱引用 与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期 被弱引用关联的对象只能生存到下一次垃圾回收发生之前。 只要垃圾回收机制在工作，无论内存是否足够，都会回收掉这部分对象。 虚引用 虚引用在任何时候都可能被垃圾回收器回收。一个对象是否被虚引用关联，完全不对其生存周期构成影响。 主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。 必须 和引用队列 （ReferenceQueue）联合使用。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 不能通过一个虚引用获取到一个对象实例 GC回收机制Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。 GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。 程序员不用担心内存管理，GC会自动进行管理。 GC标记对象的方法 引用计数法 给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示该对象可以被 GC 回收了， 弊端： A-&gt;B,B-&gt;A,那么 AB 将永远不会被回收了。也就是引用有环的情况 根搜索算法(可达性算法) GC Roots Tracing 通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则该对象就可以被回收。 根搜索算法中不可达的对象并非“非死不可”,真正宣告一个对象死亡需要两次标记过程。 finalize()方法只会被调用一次 GC回收的Roots包括： java虚拟机栈中引用的对象 eg: 方法里面定义这种局部变量 User user= new User(); native方法栈中引用的对象 方法区中常量引用的对象 eg: private static final User user = new User(); 方法区中静态属性引用的对象 eg: private static User user = new User(); 回收算法 标记-清除 缺点：产生内存碎片 复制算法 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉 缺点：内存缩小为原来的一半 标记-整理 标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存 优点：解决了清除算法的内存碎片问题和复制算法的效率低下问题 分代收集算法 根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代。 新生代采用复制算法，老年代采用标记-整理算法 Minor GC &amp; Full GC Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制回收算法 Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法/标记-整理算法 内存分配与回收策略 结构（堆大小 = 新生代 + 老年代） 新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（8 : 1 : 1） 老年代(2/3)(长时间存在的对象) 一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC） 如果survivor0可以放入，那么放入之后清除Eden区 如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中 如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。 如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC） 大对象、长期存活的对象则直接进入老年代 动态对象年龄判定 GC垃圾收集器 Serial New收集器：单线程，针对新生代的收集器，采用的是复制算法 Parallel New（并行）收集器：多线程，新生代采用复制算法，老年代采用标记整理 Parallel Scavenge（并行）收集器：多线程，针对新生代，采用复制算法 Serial Old（串行）收集器：单线程，新生代采用复制，老年代采用标记整理 Parallel Old（并行）收集器：多线程，针对老年代，标记整理 CMS收集器：基于标记-清除 G1收集器(JDK)：整体上是基于标记整理，局部采用复制 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理 如何减少GC次数？ 对象尽量不要显式设置为null 少用system.gc 少用静态变量 尽量使用 StringBuffer,而不用 String 来累加字符串 使用软引用类型 Java类加载机制 虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型 类的生命周期 加载过程 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 验证过程 确保Class文件的字节流中包含的信息符合当前虚拟机的要求 准备过程 正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配 解析阶段 虚拟机将常量池内的符号引用替换为直接引用的过程 初始化阶段 类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器方法的过程 使用阶段 卸载阶段 Java类加载器 负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次 Bootstrap ClassLoader: 启动类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现 Extension ClassLoader: 扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的 System ClassLoader:系统(应用)类加载器： 它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。 双亲委派模型 工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。 除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器 优点 Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以 避免类的重复加载 考虑到安全因素，java核心api中定义类型不会被随意替换 eg:假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class JAVA内存模型(JMM) 主要目标 定义程序中各个变量的访问规则 线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量 先行发生原则happens-before 如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和排序算法]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本排序算法 稳定性 排序前后两个相等的数相对位置不变，则算法稳定。插入排序 直接插入排序 折半插入排序（二分法插入） 希尔排序：不稳定 直接插入排序稳定，算法复杂度：O(n²) public void insertionSort(int[] a) { for (int i = 1; i &lt; a.length; i++) { int temp = a[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) { a[j + 1] = a[j]; j--; } a[j + 1] = temp; } } 折半插入排序（此处描述的是二分法查找算法）稳定，查找算法复杂度：O(logN)；排序算法复杂度：O(NlogN) 要求：1.存储在数组中（链表中不适合） 2.有序排列 在算法中属于分治算法 //递归实现 public int binarySearchRecursion(int[] array, int low, int high, int target) { if (low &gt; high) return -1; int mid = (low + high) / 2; if (target &lt; array[mid]) return binarySearchRecursion(array, low, mid - 1, target); if (target &gt; array[mid]) return binarySearchRecursion(array, mid + 1, high, target); return array[mid]; } //非递归实现 public int binarySearch(int[] array, int low, int high, int target) { while (low &lt;= high) { int mid = (low + high) / 2; if (target &lt; array[mid]) high = mid - 1; else if (target &gt; array[mid]) low = mid + 1; else return mid; } return -1; } 交换排序 冒泡排序 快速排序(不稳定) 冒泡排序稳定，算法复杂度：O(n²)；最好情况下O(n) public void bubbleSort(int[] a) { for (int i = 0; i &lt; a.length; i++) { for (int j = 1; j &lt; a.length - i; j++) { if (a[j] &lt; a[j - 1]) { int temp = a[j]; a[j] = a[j - 1]; a[j - 1] = temp; } } } } //算法还可以改进，从两头向中间逼近，可以加快速度 快速排序不稳定，算法复杂度：O(NlogN) 在所有同数量级的排序方法中，平均性能最好 //递归实现 public void quickSortRecursion(int[] arr, int low, int high) { if (low &lt; high) { int pivot = partition(arr, low, high); quickSortRecursion(arr, low, pivot - 1); quickSortRecursion(arr, pivot + 1, high); } } private int partition(int[] arr, int low, int high) { int pivot = arr[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; arr[high] &gt; pivot) high--; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt; pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } //非递归实现 public void quickSort(int[] arr, int low, int high) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if (low &lt; high) { stack.push(high); stack.push(low); while (!stack.empty()) { int l = stack.pop(); int r = stack.pop(); int pivot = partition(arr, l, r); if (l &lt; pivot - 1) { stack.push(pivot - 1); stack.push(l); } if (r &gt; pivot + 1) { stack.push(r); stack.push(pivot + 1); } } } } 选择排序 直接选择排序：不稳定 直接选择最小(最大)的记录与第一个记录交换位置，再对余下的n-1个进行同样操作 算法复杂度：O(n²) 存在重复做比较的情况 锦标赛排序（树形）：稳定 N个关键码两两比较，得到 n/2 个比较的优胜者(关键码小者)保留下来, 再对这 n/2个对象再进行关键码的两两比较, ……直至选出一个最小的关键码为止。 算法复杂度：O(NlogN) 堆排序：不稳定 算法复杂度：O(NlogN) 堆排序//堆排序 public void heapsort(int[] arr) { for (int i = arr.length / 2; i &gt;= 0; i--) adjustHeap(arr, i, arr.length); for (int i = arr.length - 1; i &gt; 0; i--) { swap(arr, 0, i); adjustHeap(arr, 0, i); } } /** 构建最大堆的过程 * @param arr 数组 * @param i 需要构建堆的根节点的序号 * @param n 数组长度 ** / public void adjustHeap(int[] arr, int i, int n) { int father; int child; for (father = arr[i]; leftChild(i) &lt; n; i = child) { child = leftChild(i); // 如果左子树小于右子树，则需要比较右子树和父节点 if (child != n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) child++;//序号+1，指向右子树 // 如果父节点小于孩子结点，则需要交换 if (father &lt; arr[child]) { arr[i] = arr[child]; } else break;//是最大堆，无需破坏 } arr[i] = father; } private int leftChild(int i) { return 2 * i + 1; } private void swap(int[] arr, int index1, int index2) { int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; } 归并排序稳定，算法复杂度：O(NlogN) 在算法中属于分治算法 //递归 public void MergeSort(int[] arr, int left, int right) { int mid = (left + right) / 2; if (left &lt; right){ MergeSort(arr, left, mid); MergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } } //merge函数实际上是将两个有序数组合并成一个有序数组 //因为数组有序，合并很简单，只要维护几个指针就可以了 private void merge(int[] arr, int left, int mid, int right) { //temp数组用于暂存合并的结果 int[] temp = new int[right - left + 1]; //左半边的指针 int head1 = left; //右半边的指针 int head2 = mid+1; //合并后数组的指针 int index = 0; //将记录由小到大地放进temp数组 for(; head1 &lt;= mid &amp;&amp; head2 &lt;= right; index++) { if(arr[head1] &lt; arr[head2]) temp[index] = arr[head1++]; else temp[index] = arr[head2++]; } //接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中 while(head1 &lt;= mid) temp[index++] = arr[head1++]; while(head2 &lt;= right) temp[index++] = arr[head2++]; //将temp数组中的元素写入到待排数组中 for(int i = 0; i &lt; temp.length; i++) arr[left + i] = temp[i]; } //非递归 private void MergeSort(int[] arr) { int len = arr.length; int step = 1; //每一个区间的长度，1,2,4,8... while (step &lt;= len) { int offset = 2 * step; for (int i = 0; i &lt; len; i += offset) merge(arr, i, Math.min(i + step - 1, len - 1), Math.min(i + offset - 1, len - 1)); step = offset; } } 基数排序 桶排序：稳定 算法复杂度：O(n+radix) 空间复杂度：O(n+2radix) 解决Hash冲突 线性探测 二次探测 双散列 d = hash1(k) = k % len(tableSize) c = hash2(k) = R - (k % R) ;R为&lt;tableSize的质数 d+c,d+2c,d+3c….. 再散列 当表项数 &gt; 表的70% 时,可再散列. 即, 取比(2*原表长=14)大的质数17再散列]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法整理]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[常用算法(一) 穷举法(二) 贪婪算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪婪算法不能保证全局最优，所以使用贪心算法的前提是，局部最优策略能导致全局最优解。同时贪心算法必须满足无后效性，即某个状态以后的状态不会影响以前的状态。 适用情况局部最优策略能导致全局最优解 基本思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把局部最优解合成原来问题的一个解 经典问题 霍夫曼编码 最小生成树 0/1背包问题 (三) 动态规划 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用情况 最优化原理：问题的最优解所包含的子问题的解也是最优的 无后效性：某阶段状态一旦确定，就不受这个状态以后决策的影响 有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。 基本思路初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 划分：划分后的阶段一定要是有序的或者是可排序的 确定状态和状态变量：要满足无后效性 确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态 寻找边界条件 经典问题 N级台阶问题 最长递增子序列 (四) 分治算法把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 适用情况 问题的复杂性随问题的规模递增 最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解 如果不满足第三条，可以用贪心算法Or动态规划算法 子问题之间相互独立 基本思路分解-解决-合并 ###经典问题 快速排序 归并排序 二分查找 (五) 回溯法回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 **深度优先搜索策略** 基本思路 确定问题的解空间 确定节点的扩展搜索规则 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索 (六) 分支界限算法回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 **广度优先搜索策略** 分支搜索算法 FIFO搜索 LIFO搜索 优先队列式搜索]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[微服务架构http://dockone.io/article/3687 https://www.kancloud.cn/good-rain/micro-services/248952 API网关比较NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerdhttps://juejin.im/entry/5ad408de6fb9a028cc61af94]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
</search>
