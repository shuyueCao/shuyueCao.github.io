<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM整理]]></title>
    <url>%2F2019%2F01%2F19%2FJVM%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[JVM运行内存的分类 程序计数器 线程私有 当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址 如果正在执行的是native方法，则为空 虚拟机栈 线程私有 每个方法被执行的时候都会同时创建一个栈帧用于存放局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 生命周期与线程相同 为java方法服务 native方法栈 与java虚拟机栈相似 区别：为native方法服务 java堆 线程共享 JVM所管理的内存中最大的一块，在虚拟机启动时创建 唯一目的：存放对象实例、数组 GC回收的主要区域 方法区 线程共享 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 回收目标：主要是常量池的回收和类型的卸载 Java四大引用 强引用 如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题 例子：Object obj = new Object(); 这里obj 就是引用，new Object() 对象实例存储在堆内存，obj引用的是对象实例的内存地址。 软引用 可以和一个引用队列（ReferenceQueue) 联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中 用来描述可用但不是必须存活的对象；在内存溢出之前，虚拟机尝试对这些对象进行回收。如果回收之后内存还是不够才会出现内存溢出情况。 弱引用 与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期 被弱引用关联的对象只能生存到下一次垃圾回收发生之前。 只要垃圾回收机制在工作，无论内存是否足够，都会回收掉这部分对象。 虚引用 虚引用在任何时候都可能被垃圾回收器回收。一个对象是否被虚引用关联，完全不对其生存周期构成影响。 主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。 必须 和引用队列 （ReferenceQueue）联合使用。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 不能通过一个虚引用获取到一个对象实例 GC回收机制Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。 GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。 程序员不用担心内存管理，GC会自动进行管理。 GC标记对象的方法 引用计数法 给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示该对象可以被 GC 回收了， 弊端： A-&gt;B,B-&gt;A,那么 AB 将永远不会被回收了。也就是引用有环的情况 根搜索算法(可达性算法) GC Roots Tracing 通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则该对象就可以被回收。 根搜索算法中不可达的对象并非“非死不可”,真正宣告一个对象死亡需要两次标记过程。 finalize()方法只会被调用一次 GC回收的Roots包括： java虚拟机栈中引用的对象 eg: 方法里面定义这种局部变量 User user= new User(); native方法栈中引用的对象 方法区中常量引用的对象 eg: private static final User user = new User(); 方法区中静态属性引用的对象 eg: private static User user = new User(); 回收算法 标记-清除 缺点：产生内存碎片 复制算法 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉 缺点：内存缩小为原来的一半 标记-整理 标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存 优点：解决了清除算法的内存碎片问题和复制算法的效率低下问题 分代收集算法 根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代。 新生代采用复制算法，老年代采用标记-整理算法 Minor GC &amp; Full GC Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制回收算法 Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法/标记-整理算法 内存分配与回收策略 结构（堆大小 = 新生代 + 老年代） 新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（8 : 1 : 1） 老年代(2/3)(长时间存在的对象) 一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC） 如果survivor0可以放入，那么放入之后清除Eden区 如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中 如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。 如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC） 大对象、长期存活的对象则直接进入老年代 动态对象年龄判定 GC垃圾收集器 Serial New收集器：单线程，针对新生代的收集器，采用的是复制算法 Parallel New（并行）收集器：多线程，新生代采用复制算法，老年代采用标记整理 Parallel Scavenge（并行）收集器：多线程，针对新生代，采用复制算法 Serial Old（串行）收集器：单线程，新生代采用复制，老年代采用标记整理 Parallel Old（并行）收集器：多线程，针对老年代，标记整理 CMS收集器：基于标记-清除 G1收集器(JDK)：整体上是基于标记整理，局部采用复制 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理 Java类加载机制 虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型 类的生命周期 加载过程 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 验证过程 确保Class文件的字节流中包含的信息符合当前虚拟机的要求 准备过程 正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配 解析阶段 虚拟机将常量池内的符号引用替换为直接引用的过程 初始化阶段 类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器方法的过程 使用阶段 卸载阶段 Java类加载器 负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次 Bootstrap ClassLoader: 根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现 Extension ClassLoader: 扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的 System ClassLoader:系统(应用)类加载器： 它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和排序算法]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本排序算法插入排序 直接插入排序 折半插入排序（二分法插入） 希尔排序：不稳定 直接插入排序稳定，算法复杂度：O(n²) public void insertionSort(int[] a) { for (int i = 1; i &lt; a.length; i++) { int temp = a[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) { a[j + 1] = a[j]; j--; } a[j + 1] = temp; } } 折半插入排序（此处描述的是二分法查找算法）稳定，查找算法复杂度：O(logN)；排序算法复杂度：O(NlogN) 要求：1.存储在数组中（链表中不适合） 2.有序排列 在算法中属于分治算法 //递归实现 public int binarySearchRecursion(int[] array, int low, int high, int target) { if (low &gt; high) return -1; int mid = (low + high) / 2; if (target &lt; array[mid]) return binarySearchRecursion(array, low, mid - 1, target); if (target &gt; array[mid]) return binarySearchRecursion(array, mid + 1, high, target); return array[mid]; } //非递归实现 public int binarySearch(int[] array, int low, int high, int target) { while (low &lt;= high) { int mid = (low + high) / 2; if (target &lt; array[mid]) high = mid - 1; else if (target &gt; array[mid]) low = mid + 1; else return mid; } return -1; } 交换排序 冒泡排序 快速排序(不稳定) 冒泡排序稳定，算法复杂度：O(n²)；最好情况下O(n) public void bubbleSort(int[] a) { for (int i = 0; i &lt; a.length; i++) { for (int j = 1; j &lt; a.length - i; j++) { if (a[j] &lt; a[j - 1]) { int temp = a[j]; a[j] = a[j - 1]; a[j - 1] = temp; } } } } //算法还可以改进，从两头向中间逼近，可以加快速度 快速排序不稳定，算法复杂度：O(NlogN) 在所有同数量级的排序方法中，平均性能最好 //递归实现 public void quickSortRecursion(int[] arr, int low, int high) { if (low &lt; high) { int pivot = partition(arr, low, high); partition(arr, low, pivot - 1); partition(arr, pivot + 1, high); } } private int partition(int[] arr, int low, int high) { int pivot = arr[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; arr[high] &gt; pivot) high--; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt; pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } //非递归实现 public void quickSort(int[] arr, int low, int high) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if (low &lt; high) { stack.push(high); stack.push(low); while (!stack.empty()) { int l = stack.pop(); int r = stack.pop(); int pivot = partition(arr, l, r); if (l &lt; pivot - 1) { stack.push(pivot - 1); stack.push(l); } if (r &gt; pivot + 1) { stack.push(r); stack.push(pivot + 1); } } } } 选择排序 直接选择排序：不稳定 直接选择最小(最大)的记录与第一个记录交换位置，再对余下的n-1个进行同样操作 算法复杂度：O(n²) 存在重复做比较的情况 锦标赛排序（树形）：稳定 N个关键码两两比较，得到 n/2 个比较的优胜者(关键码小者)保留下来, 再对这 n/2个对象再进行关键码的两两比较, ……直至选出一个最小的关键码为止。 算法复杂度：O(NlogN) 堆排序：不稳定 算法复杂度：O(NlogN) 堆排序//堆排序 public void heapsort(int[] arr) { for (int i = arr.length / 2; i &gt;= 0; i--) adjustHeap(arr, i, arr.length); for (int i = arr.length - 1; i &gt; 0; i--) { swap(arr, 0, i); adjustHeap(arr, 0, i); } } /** 构建最大堆的过程 * @param arr 数组 * @param i 需要构建堆的根节点的序号 * @param n 数组长度 ** / public void adjustHeap(int[] arr, int i, int n) { int father; int child; for (father = arr[i]; leftChild(i) &lt; n; i = child) { child = leftChild(i); // 如果左子树小于右子树，则需要比较右子树和父节点 if (child != n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) child++;//序号+1，指向右子树 // 如果父节点小于孩子结点，则需要交换 if (father &lt; arr[child]) { arr[i] = arr[child]; } else break;//是最大堆，无需破坏 } arr[i] = father; } private int leftChild(int i) { return 2 * i + 1; } private void swap(int[] arr, int index1, int index2) { int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; } 归并排序稳定，算法复杂度：O(NlogN) 在算法中属于分治算法 //递归 public void MergeSort(int[] arr, int left, int right) { int mid = (left + right) / 2; if (left &lt; right){ MergeSort(arr, left, mid); MergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } } //merge函数实际上是将两个有序数组合并成一个有序数组 //因为数组有序，合并很简单，只要维护几个指针就可以了 private void merge(int[] arr, int left, int mid, int right) { //temp数组用于暂存合并的结果 int[] temp = new int[right - left + 1]; //左半边的指针 int head1 = left; //右半边的指针 int head2 = mid+1; //合并后数组的指针 int index = 0; //将记录由小到大地放进temp数组 for(; head1 &lt;= mid &amp;&amp; head2 &lt;= right; index++) { if(arr[head1] &lt; arr[head2]) temp[index] = arr[head1++]; else temp[index] = arr[head2++]; } //接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中 while(head1 &lt;= mid) temp[index++] = arr[head1++]; while(head2 &lt;= right) temp[index++] = arr[head2++]; //将temp数组中的元素写入到待排数组中 for(int i = 0; i &lt; temp.length; i++) arr[left + i] = temp[i]; } //非递归 private void MergeSort(int[] arr) { int len = arr.length; int step = 1; //每一个区间的长度，1,2,4,8... while (step &lt;= len) { int offset = 2 * step; for (int i = 0; i &lt; len; i += offset) merge(arr, i, Math.min(i + step - 1, len - 1), Math.min(i + offset - 1, len - 1)); step = offset; } } 基数排序 桶排序：稳定]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法整理]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[常用算法(一) 穷举法(二) 贪婪算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪婪算法不能保证全局最优，所以使用贪心算法的前提是，局部最优策略能导致全局最优解。同时贪心算法必须满足无后效性，即某个状态以后的状态不会影响以前的状态。 适用情况局部最优策略能导致全局最优解 基本思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把局部最优解合成原来问题的一个解 经典问题 霍夫曼编码 最小生成树 0/1背包问题 (三) 动态规划 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用情况 最优化原理：问题的最优解所包含的子问题的解也是最优的 无后效性：某阶段状态一旦确定，就不受这个状态以后决策的影响 有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。 基本思路初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 划分：划分后的阶段一定要是有序的或者是可排序的 确定状态和状态变量：要满足无后效性 确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态 寻找边界条件 经典问题 N级台阶问题 最长递增子序列 (四) 分治算法把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 适用情况 问题的复杂性随问题的规模递增 最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解 如果不满足第三条，可以用贪心算法Or动态规划算法 子问题之间相互独立 基本思路分解-解决-合并 ###经典问题 快速排序 归并排序 二分查找 (五) 回溯法回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 **深度优先搜索策略** 基本思路 确定问题的解空间 确定节点的扩展搜索规则 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索 (六) 分支界限算法回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 **广度优先搜索策略** 分支搜索算法 FIFO搜索 LIFO搜索 优先队列式搜索]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[微服务架构http://dockone.io/article/3687 https://www.kancloud.cn/good-rain/micro-services/248952 API网关比较NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerdhttps://juejin.im/entry/5ad408de6fb9a028cc61af94]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
</search>
