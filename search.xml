<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构和排序算法]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本排序算法插入排序 直接插入排序 折半插入排序（二分法插入） 希尔排序：不稳定 直接插入排序稳定，算法复杂度：O(n²) public void insertionSort(int[] a) { for (int i = 1; i &lt; a.length; i++) { int temp = a[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) { a[j + 1] = a[j]; j--; } a[j + 1] = temp; } } 折半插入排序（此处描述的是二分法查找算法）稳定，查找算法复杂度：O(logN)；排序算法复杂度：O(NlogN) 要求：1.存储在数组中（链表中不适合） 2.有序排列 在算法中属于分治算法 //递归实现 public int binarySearchRecursion(int[] array, int low, int high, int target) { if (low &gt; high) return -1; int mid = (low + high) / 2; if (target &lt; array[mid]) return binarySearchRecursion(array, low, mid - 1, target); if (target &gt; array[mid]) return binarySearchRecursion(array, mid + 1, high, target); return array[mid]; } //非递归实现 public int binarySearch(int[] array, int low, int high, int target) { while (low &lt;= high) { int mid = (low + high) / 2; if (target &lt; array[mid]) high = mid - 1; else if (target &gt; array[mid]) low = mid + 1; else return mid; } return -1; } 交换排序 冒泡排序 快速排序(不稳定) 冒泡排序稳定，算法复杂度：O(n²)；最好情况下O(n) public void bubbleSort(int[] a) { for (int i = 0; i &lt; a.length; i++) { for (int j = 1; j &lt; a.length - i; j++) { if (a[j] &lt; a[j - 1]) { int temp = a[j]; a[j] = a[j - 1]; a[j - 1] = temp; } } } } //算法还可以改进，从两头向中间逼近，可以加快速度 快速排序不稳定，算法复杂度：O(NlogN) 在所有同数量级的排序方法中，平均性能最好 //递归实现 public void quickSortRecursion(int[] arr, int low, int high) { if (low &lt; high) { int pivot = partition(arr, low, high); partition(arr, low, pivot - 1); partition(arr, pivot + 1, high); } } private int partition(int[] arr, int low, int high) { int pivot = arr[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; arr[high] &gt; pivot) high--; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt; pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } //非递归实现 public void quickSort(int[] arr, int low, int high) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if (low &lt; high) { stack.push(high); stack.push(low); while (!stack.empty()) { int l = stack.pop(); int r = stack.pop(); int pivot = partition(arr, l, r); if (l &lt; pivot - 1) { stack.push(pivot - 1); stack.push(l); } if (r &gt; pivot + 1) { stack.push(r); stack.push(pivot + 1); } } } } 选择排序 直接选择排序：不稳定 直接选择最小(最大)的记录与第一个记录交换位置，再对余下的n-1个进行同样操作 算法复杂度：O(n²) 存在重复做比较的情况 锦标赛排序（树形）：稳定 N个关键码两两比较，得到 n/2 个比较的优胜者(关键码小者)保留下来, 再对这 n/2个对象再进行关键码的两两比较, ……直至选出一个最小的关键码为止。 算法复杂度：O(NlogN) 堆排序：不稳定 算法复杂度：O(NlogN) 归并排序稳定，算法复杂度：O(NlogN) 在算法中属于分治算法 //递归 public void MergeSort(int[] arr, int left, int right) { int mid = (left + right) / 2; if (left &lt; right){ MergeSort(arr, left, mid); MergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } } //merge函数实际上是将两个有序数组合并成一个有序数组 //因为数组有序，合并很简单，只要维护几个指针就可以了 private void merge(int[] arr, int left, int mid, int right) { //temp数组用于暂存合并的结果 int[] temp = new int[right - left + 1]; //左半边的指针 int head1 = left; //右半边的指针 int head2 = mid+1; //合并后数组的指针 int index = 0; //将记录由小到大地放进temp数组 for(; head1 &lt;= mid &amp;&amp; head2 &lt;= right; index++) { if(arr[head1] &lt; arr[head2]) temp[index] = arr[head1++]; else temp[index] = arr[head2++]; } //接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中 while(head1 &lt;= mid) temp[index++] = arr[head1++]; while(head2 &lt;= right) temp[index++] = arr[head2++]; //将temp数组中的元素写入到待排数组中 for(int i = 0; i &lt; temp.length; i++) arr[left + i] = temp[i]; } //非递归 private void MergeSort(int[] arr) { int len = arr.length; int step = 1; //每一个区间的长度，1,2,4,8... while (step &lt;= len) { int offset = 2 * step; for (int i = 0; i &lt; len; i += offset) merge(arr, i, Math.min(i + step - 1, len - 1), Math.min(i + offset - 1, len - 1)); step = offset; } }]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法整理]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[常用算法(一) 穷举法(二) 贪婪算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪婪算法不能保证全局最优，所以使用贪心算法的前提是，局部最优策略能导致全局最优解。同时贪心算法必须满足无后效性，即某个状态以后的状态不会影响以前的状态。 适用情况局部最优策略能导致全局最优解 基本思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把局部最优解合成原来问题的一个解 经典问题 霍夫曼编码 最小生成树 0/1背包问题 (三) 动态规划 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用情况 最优化原理：问题的最优解所包含的子问题的解也是最优的 无后效性：某阶段状态一旦确定，就不受这个状态以后决策的影响 有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。 基本思路初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 划分：划分后的阶段一定要是有序的或者是可排序的 确定状态和状态变量：要满足无后效性 确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态 寻找边界条件 经典问题 N级台阶问题 最长递增子序列 (四) 分治算法把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 适用情况 问题的复杂性随问题的规模递增 最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解 如果不满足第三条，可以用贪心算法Or动态规划算法 子问题之间相互独立 基本思路分解-解决-合并 ###经典问题 快速排序 归并排序 二分查找 (五) 回溯法回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 **深度优先搜索策略** 基本思路 确定问题的解空间 确定节点的扩展搜索规则 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索 (六) 分支界限算法回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 **广度优先搜索策略** 分支搜索算法 FIFO搜索 LIFO搜索 优先队列式搜索]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[微服务架构http://dockone.io/article/3687 https://www.kancloud.cn/good-rain/micro-services/248952 API网关比较NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerdhttps://juejin.im/entry/5ad408de6fb9a028cc61af94]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微软算法100题]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%BE%AE%E8%BD%AF%E7%AE%97%E6%B3%95100%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前40题https://bbs.csdn.net/topics/350118968]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
