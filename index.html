<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="Java">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="用来记录一些知识~">
<meta property="og:type" content="website">
<meta property="og:title" content="Alpaca&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Alpaca&#39;s Blog">
<meta property="og:description" content="用来记录一些知识~">
<meta property="og:locale" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alpaca&#39;s Blog">
<meta name="twitter:description" content="用来记录一些知识~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Alpaca's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="Java">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alpaca's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">总有一天想去的地方都会去到的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/数据库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/数据库/" itemprop="url">数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T10:23:38+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>key-value类型的内存(缓存)数据库</li>
<li>整个数据库加载到内存中操作，定期flush到硬盘上进行保存</li>
<li>单线程</li>
<li><p>集群是master/slave模式</p>
</li>
<li><p><strong>与memchached的区别</strong></p>
<ul>
<li>memchached仅支持string类型，Redis支持更丰富的数据类型</li>
<li>Redis速度更快</li>
<li>Redis可以持久化</li>
</ul>
</li>
<li><p><strong>支持的数据类型和底层实现</strong></p>
<ul>
<li><strong>在Redis中，所有key-value对都存储在一个hash table中</strong><ul>
<li>Hash table是一个二维结构</li>
<li>一个一维固定长度的数组，每个槽位上保存一个dictEntry对象。key计算hash值后按照这个定长数组<strong>求模</strong>，结果相同的key-balue通过<strong>链表</strong>保存在同一个槽位上，这样便形成了一个二维结构</li>
</ul>
</li>
<li>String<ul>
<li>能存为整数则存为整数，不能则存为原始字符串</li>
</ul>
</li>
<li>List<ul>
<li>使用 zip List结构</li>
<li>zip list通过一个连续的内存块实现list结构，其中的每个entry节点头部保存前后节点<em>长度信息</em>，实现双向链表功能</li>
<li>当list内容较多时，使用双向链表</li>
</ul>
</li>
<li>hash<ul>
<li>新建的Hash类型也使用zip list存储value</li>
<li>保存数据过多时，转而使用hash table</li>
</ul>
</li>
<li>set<ul>
<li>创如果value能够表示为整数，则使用intset类型保存value。intset使用和ziplist相似的实现方式保存整数</li>
<li>数据量大时，切换为使用hash table</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li>会话缓存</li>
<li>队列</li>
<li>发布/订阅</li>
<li>排行榜/计数器</li>
</ul>
</li>
<li>如何做内存优化？<ul>
<li>使用hashes(散列表)</li>
</ul>
</li>
<li>Redis是单线程，如何提高CPU利用率？<ul>
<li>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用</li>
</ul>
</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><strong>索引</strong><ul>
<li>原理<ul>
<li>对要查询的字段建立索引其实就是把该字段按照一定的方式排序；建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效了</li>
</ul>
</li>
<li>优点<ul>
<li>加快数据检索速度，提高对数据访问效率</li>
<li>提高数据查询性能</li>
</ul>
</li>
<li>缺点<ul>
<li>占用大量硬盘空间</li>
<li>数据的增删改等更新操作，需要维护索引时间，<em>降低更新速度</em></li>
</ul>
</li>
<li>适用场合<ul>
<li>主键列中创建索引</li>
<li>多表连接时连接列创建索引</li>
<li>where子句查询的列</li>
<li>需要经常GROUP BY和ORDER BY的列</li>
</ul>
</li>
</ul>
</li>
<li><strong>类型</strong><ul>
<li>主键索引</li>
<li>普通索引/单列索引</li>
<li>多列索引/复合索引<ul>
<li>使用复合索引时遵循最左前缀原则</li>
<li>最左前缀原则<ul>
<li>最左优先，先要看第一列，在第一列满足的条件下再看左边第二列，以此类推</li>
<li>eg: 多列字段做索引，state/city/zipCode，想要索引生效的话，只能使用如下的组合：state/city/zipCode，state/city，state。<br>其他方式（如city，city/zipCode），则索引不会生效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><ul>
<li><strong>B+树</strong><ul>
<li>特点<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点不存储数据，只存储指针索引(洗漱索引)；叶子节点存储所有关键字数据(稠密索引)，不存储指针</li>
<li>在经典B+树基础上增加了<strong>顺序访问指针</strong>，每个叶子节点都有指向相邻下一个叶子节点的指针<ul>
<li><strong>提高区间访问的性能</strong></li>
</ul>
</li>
<li>更适合文件系统</li>
</ul>
</li>
</ul>
</li>
<li><strong>为什么说B+树比B树更适合数据库索引？</strong><ul>
<li><strong>B+树的磁盘读写代价更低</strong><ul>
<li>B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了</li>
</ul>
</li>
<li><strong>B+树的查询效率更加稳定</strong><ul>
<li>任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
</li>
<li><strong>方便扫库</strong><ul>
<li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，只需要扫一遍叶子结点即可</li>
</ul>
</li>
<li><strong>范围扫描更简单</strong></li>
<li><strong>内部节点可以定位更多叶子节点</strong></li>
</ul>
</li>
</ul>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><ul>
<li>重写order by语句以使用索引</li>
<li>SELECT子句中避免使用 ‘ * ‘</li>
<li>减少访问数据库的次数</li>
<li>用Where子句替换HAVING子句/order by</li>
<li>通过内部函数提高SQL效率</li>
<li>用EXISTS替代IN、用NOT EXISTS替代NOT IN</li>
<li>使用索引</li>
<li>避免在索引列上使用NOT</li>
<li>避免在索引列上使用计算</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>概念<ul>
<li>指访问并可能更新数据库中各种数据项的一个程序执行单元</li>
<li>对数据库进行读或写的一个操作序列</li>
</ul>
</li>
<li>特性<ul>
<li>原子性(A):事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性(C):事务应确保数据库的状态从一个一致状态转变为另一个一致状态。</li>
<li>隔离性(I):一个事务的执行不应影响其他事务的执行</li>
<li>持久性(D):一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><strong>脏读</strong><ul>
<li>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
</ul>
</li>
<li><strong>不可重复读</strong><ul>
<li>指在一个事务内，多次读同一数据。两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的</li>
</ul>
</li>
<li><strong>幻读</strong><ul>
<li>第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</li>
</ul>
</li>
<li>级别<ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<ul>
<li>四级封锁协议：其他事务不能 读写 该表中的任何数据</li>
</ul>
</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。<ul>
<li>三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放</li>
</ul>
</li>
<li>Read committed (读已提交)：可避免脏读的发生。<ul>
<li>二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁 <strong>（瞬间S锁）</strong>。</li>
</ul>
</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<ul>
<li>一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul>
<li>排他锁/写锁/x锁<ul>
<li>事务T可以修改A也可以读A，其他事务不能再对A加任何锁，直到事务T释放A上的锁</li>
</ul>
</li>
<li>共享锁/读锁/s锁<ul>
<li>其他事务可以读A，而在事务T释放A上的S锁之前不能对A进行修改</li>
</ul>
</li>
<li>死锁<ul>
<li>互相等待</li>
<li>形成条件<ul>
<li>互斥：排它性</li>
<li>请求和保持：对自己已获得的其它资源保持不释放</li>
<li>不剥夺：不能被剥夺，只能在使用完时由自己释放</li>
<li>循环等待</li>
</ul>
</li>
<li>预防和解除<ul>
<li>预防：破坏四个条件之一</li>
<li>避免：银行家算法</li>
<li>解除<ul>
<li>剥夺资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>活锁<ul>
<li>某一个事务T可能饿死(永远等待)</li>
<li>避免活锁的简单方法是采用先来先服务的策略。</li>
</ul>
</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul>
<li>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/java多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/java多线程/" itemprop="url">java多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T11:58:53+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h6 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h6><ul>
<li>继Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口(比runnable多一个返回值)</li>
</ul>
<p>Java不支持多继承，但可以实现多个接口。</p>
<ul>
<li>start()方法会启动一个新线程，并包含run()方法。而run()只会执行run方法，不会启动新线程</li>
</ul>
<h6 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h6><ul>
<li>为什么要用线程池？<ul>
<li>降低消耗。降低创建和销毁线程造成的消耗</li>
<li>提高响应速度。任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性</li>
</ul>
</li>
<li><strong>参数</strong><ul>
<li><strong>corePoolSize：线程池核心线程数量</strong><ul>
<li>如果池中线程数量少于核心线程池数量，则直接新建线程处理当前任务</li>
<li>当池中无空闲线程时，新任务将被添加到阻塞队列</li>
<li>核心线程池空闲不会被回收。</li>
</ul>
</li>
<li><strong>maximumPoolSize：线程池最大线程数量</strong><ul>
<li>当阻塞队列已满，并且有新任务还在入队时，创建新的线程处理，直到线程数大于maximumPoolSize</li>
<li>超出corePoolSize部分的线程超过空闲时间后会被回收</li>
<li>当线程已经超出maximumPoolSize，并且阻塞队列已满，则通过handler所指定的策略来处理任务。</li>
</ul>
</li>
<li><strong>keepAliveTime：线程存活时间</strong><ul>
<li>当线程超出corePoolSize时生效</li>
</ul>
</li>
<li><strong>workQueue：阻塞队列（存储等待执行的任务）</strong></li>
<li><strong>threadFactory：线程工厂，用来创建线程</strong></li>
</ul>
</li>
</ul>
<h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><ul>
<li>用于线程间的数据隔离</li>
<li>使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li>
</ul>
<h3 id="Wait-Notify-NotifyAll"><a href="#Wait-Notify-NotifyAll" class="headerlink" title="Wait/Notify/NotifyAll"></a>Wait/Notify/NotifyAll</h3><ul>
<li>wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类<ul>
<li>why？</li>
</ul>
</li>
<li>wait():线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。</li>
<li>notify():唤醒一个正在等待该锁的对象</li>
<li>notifyAll():唤醒所有等待该锁的对象，但这些对象会竞争，只有一个获得该锁</li>
</ul>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><h6 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h6><ul>
<li>修饰实例方法，对当前实例加锁，进入同步代码之前需要获得当前实例的锁</li>
<li>修饰静态方法，对当前类对象加锁，进入同步代码之前需要获得当前类对象的锁。</li>
<li>修饰代码块，对指定对象加锁，进入同步代码之前需要获得指定对象的锁。<h6 id="与LOCK的区别"><a href="#与LOCK的区别" class="headerlink" title="与LOCK的区别"></a>与LOCK的区别</h6></li>
<li>对于synchronized,如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。Lock可以提高多个线程进行读操作的效率</li>
<li>Lock可以知道线程有没有成功获取到锁。synchronized不行</li>
<li>采用synchronized不需要用户去手动释放锁，而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行</li>
<li>synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</li>
</ul>
<h6 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h6><ul>
<li>与synchronized一样都可重入，同一线程可以多次获得同一个锁</li>
<li>实现了Lock接口</li>
<li>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li>
<li>ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
</ul>
<h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><p><strong>作用：</strong></p>
<ul>
<li>JVM提供的最轻量级的同步机制</li>
<li>一个变量使用volatile之后，具备两种特性：<ul>
<li>保证此变量对所有线程的可见性<ul>
<li>符合以下两条规则才能保证原子性：<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
</li>
</ul>
</li>
<li>禁止指令重排序优化</li>
</ul>
</li>
<li><p>eg:</p>
<pre><code>//1
volatile boolean shutdownRequested;

public void shutdown() {
    shutdownRequested = true;
}

public void doWork() {
  while (!shutdownRequested) {
  //do stuff
  }
}

//2
public class ChessyCounter{
  @GuardedBy(&quot;this&quot;) private volatile int value;

  //读操作，没有synchronized，提高性能
  public int getValue(){
    return value
  }

  //写操作，必须synchronized。因为x++不是原子操作
  public synchronized int increment() {
    return value++;
  }
}
//锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作
//使用锁进行所有变化的操作，使用 volatile 进行只读操作。
</code></pre></li>
</ul>
<p><strong>与synchronized区别：</strong></p>
<ul>
<li>synchronized关键字解决的是执行控制的问题，volatile关键字解决的是内存可见性的问题</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/操作系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/操作系统/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-27T10:51:12+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h3><p><strong>1. 进程线程区别与联系</strong></p>
<ul>
<li>区别：<ul>
<li>进程是资源分配的最小单位；线程是CPU调度的最小单位</li>
<li>进程切换消耗资源更大</li>
<li>线程的划分尺度小于进程，导致多线程并发性更高</li>
<li>线程拥有自己独立的栈和栈指针等信息</li>
</ul>
</li>
<li>联系：<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享所在进程的内存</li>
</ul>
</li>
</ul>
<p><strong>2. 进程间通信方式</strong></p>
<ul>
<li>管道：半双工，是数据只能单向流动<ul>
<li>无名管道：只能在具有亲缘关系的进程间使用，一般指父子</li>
<li>有名管道：允许无亲缘关系进程间的通信。</li>
<li>缓冲区有限</li>
<li>只能承载无格式字节流</li>
</ul>
</li>
<li>信号量</li>
<li>消息队列<ul>
<li>可以实现任意进程间的通信，通过<em>系统调用函数</em> 来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存</li>
<li>套接字：可用于不同机器间的进程通信，用socket实现</li>
</ul>
<p><strong>3. 线程间通信方式</strong></p>
<ul>
<li>锁</li>
<li>信号量semaphore</li>
<li>信号signal</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/网络/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/网络/" itemprop="url">网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-23T11:54:52+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP-无状态的协议-HTTPS"><a href="#HTTP-无状态的协议-HTTPS" class="headerlink" title="HTTP(无状态的协议)/HTTPS"></a>HTTP(无状态的协议)/HTTPS</h3><p><strong>1. 两者区别？</strong></p>
<ol>
<li>HTTP是不安全的，HTTPS是安全的</li>
<li>OSI模型中，HTTP在应用层，HTTPS的安全传输机制在传输层</li>
<li>HTTP无法加密，HTTPS对传输的数据进行加密</li>
<li>HTTP不用证书，而HTTPS需要CA机构颁发的SSL证书</li>
</ol>
<p>HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+消息完整性保护</p>
<p><strong>2. HTTPS工作原理</strong></p>
<p><em>双向认证 SSL 协议的具体通讯过程，服务器和用户双方必须都有证书</em></p>
<ol>
<li>客户端发起HTTPS请求，服务器返回自己的证书、对称加密算法种类等信息</li>
<li>客户端判断服务器的CA证书是否由信任的CA中心签发，是则验证证书中的信息，不是则询问是否继续访问</li>
<li>客户端发送客户端证书，服务器进行相同的身份认证</li>
<li>服务器选择一种加密方案，使用<strong>客户端公钥</strong>加密后通知客户端</li>
<li>客户端通过<strong>私钥</strong>解密后得知服务器选择的加密方案，选择一个<strong>通话秘钥key</strong>，用<strong>服务器公钥</strong>加密后发给服务器</li>
<li>服务器收到后用<strong>私钥</strong>解密，获得通话秘钥key</li>
<li>接下来的数据传输都用该<strong>对称秘钥key</strong>进行加密</li>
</ol>
<p><em>通过非对称秘钥机制保证双方身份认证，完成建立连接，在实际数据通信中通过对称秘钥机制保障数据安全性</em></p>
<p><strong>3. GET与POST方法的区别？</strong></p>
<ol>
<li>GET重点在从服务器获取资源，POST重点在向服务器发送数据</li>
<li>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin</a> 这个过程用户是可见的；<br>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</li>
<li>POST比GET更安全</li>
</ol>
<h3 id="TCP-UDP（传输层）"><a href="#TCP-UDP（传输层）" class="headerlink" title="TCP / UDP（传输层）"></a>TCP / UDP（传输层）</h3><p><strong>1. TCP三次握手过程</strong></p>
<ol>
<li>主机A发送SYN包(同步序列号)到服务器 <em>(SYN_SENT)</em>，等待B确认</li>
<li>B收到后确认A的SYN <em>(SYN_RCVD)</em>，同时自己也发送一个SYN+ACK包 <em>(ESTABLISHED)</em></li>
<li>A收到SYN+ACK包后，向B发送ACK包 <em>(ESTABLISHED)</em>。完成三次握手，开始传输数据</li>
<li>三次握手特点：没有应用层的数据</li>
</ol>
<p><strong>2. TCP关闭：四次握手</strong></p>
<ol>
<li>A将FIN控制位置为1 <em>(FIN_WAIT_1)</em>，提出停止TCP的请求 <em>(CLOSE_WAIT)</em></li>
<li>B收到后对其作出响应，将ACK置为1</li>
<li>B将FIN置为1 <em>(FIN_WAIT_2)</em>，提出反方向的关闭请求  <em>(LAST_ACK)</em></li>
<li>A对B的请求进行确认 <em>(TIME_WAIT)</em>，将ACK置为1  <em>(CLOSED)</em></li>
</ol>
<p><strong><code>TIME_WAIT 状态是在服务端发送FIN，客户回复ACK后,为什么需要2MSL时间(报文最大生存时间)？</code></strong></p>
<ul>
<li>为了保证最后一个ACK因丢失，而等待重发的时间</li>
<li>保证残留网络报不会被新连接接收而产生数据错乱。保证所有残留的网络报在自己关闭前都已经超时</li>
</ul>
<hr>
<p><strong>3. TCP头部</strong></p>
<ol>
<li>16位 源端口</li>
<li>16位 目标端口</li>
<li>32位 序列号</li>
<li>32位 确认号</li>
<li>4位 头部长度：指示何处数据开始</li>
<li>16位 窗口大小</li>
<li>16位 校验和</li>
<li>16位 紧急指针</li>
</ol>
<p><strong>4. TCP如何保证可靠性传输</strong></p>
<ol>
<li>将数据截成合理长度</li>
<li>超时重发</li>
<li>推迟验证(对于收到的请求会给出确认响应，响应前会进行完整校验)<ul>
<li>如果收到的检验和有差错，TCP将丢弃这个报文，并且不确认收到此报文段。然后发送数据端会超时重发</li>
</ul>
</li>
<li>对失序数据进行重排序</li>
<li>丢弃重复数据</li>
<li>流量控制<ul>
<li>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。</li>
</ul>
</li>
</ol>
<p><strong>5.TCP粘包问题</strong></p>
<ol>
<li>粘包问题：发送方发送的若干包数据到接收方接收时粘成一包，从缓冲区来看，后一包的头紧接着前一包数据的尾<ul>
<li>可能发生的场景：需要在连接后一段时间内发送不同结构数据</li>
<li>出现原因<ul>
<li>发送端需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
</li>
<li><strong>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。</strong></li>
</ul>
</li>
<li>解决措施：<ul>
<li>对于发送方引起的粘包：编程设置，使用TCP强制数据立即传送的指令（但是关闭了优化算法）</li>
<li>对于接收方引起的粘包：优化程序设计，提高接收进程优先级等（但是无法完全避免粘包现象）</li>
<li>由接收方控制，将一包数据按结构字段，人为控制分多次接收然后合并（效率极低）</li>
</ul>
</li>
<li><strong>nagle算法</strong><ul>
<li>为了尽可能发送大块数据,避免网络中充斥着许多小数据块。</li>
<li>将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包</li>
</ul>
</li>
</ol>
<p><strong>6. TCP流量控制/拥塞控制</strong></p>
<ul>
<li>流量控制：滑动窗口<ul>
<li>让发送方的发送速率不要太快，要让接收方来得及接收</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>拥塞：对资源的需求超过了可用资源</li>
<li>慢开始：由小到大逐渐增大拥塞窗口数值(发送方的发送窗口=拥塞窗口)</li>
<li>拥塞避免算法：比慢开始算法的拥塞窗口增长速率缓慢<ul>
<li>一旦出现拥塞，将窗口大小立即置为1，执行慢开始算法</li>
</ul>
</li>
<li>快重传和快恢复<ul>
<li>接收方每收到一个失序的报文段后就立即发出重复确认</li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等重传计时器到期</li>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限减半，把拥塞窗口设置为慢开始门限减半后的数值，并执行拥塞避免算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>7. TCP和UDP区别</strong></p>
<ol>
<li>面向连接与无连接</li>
<li>对系统资源的要求(TCP较多，UDP少)</li>
<li>面向字节流和面向报文</li>
<li>TCP提供流量控制/拥塞控制，UDP无拥塞控制</li>
<li>TCP仅支持一对一</li>
<li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证</li>
</ol>
<p><code>UDP适应于对实时要求较高、不允许有较大时延的情况，如航空信息应用。</code></p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>1. 从输入URL到页面加载发生了什么？</strong></p>
<ol>
<li>DNS解析：<ul>
<li>浏览器缓存 → 系统缓存 → 路由器缓存 → ISP DNS缓存 → 递归搜索( . -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com.。" target="_blank" rel="noopener">www.google.com.。</a>)</li>
</ul>
</li>
<li>TCP连接</li>
<li>发送http请求，服务器返回一个重定向地址</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器处理http请求并返回http报文</li>
<li>浏览器解析、渲染页面</li>
</ol>
<h3 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session / Cookie"></a>Session / Cookie</h3><ul>
<li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中<ul>
<li>服务器在创建了Session的同时，会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。</li>
</ul>
</li>
<li>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式<ul>
<li>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器</li>
<li>常见应用场景：自动登录</li>
<li>安全性较低，以明文形式存放在浏览器中</li>
</ul>
</li>
<li>cookie增多会增加网络带宽，session增多会占用服务器性能</li>
<li><strong>cookie被禁用？</strong><ul>
<li>URL重写</li>
<li>每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/19/JVM整理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/19/JVM整理/" itemprop="url">JVM整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-19T10:41:03+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JVM运行内存的分类"><a href="#JVM运行内存的分类" class="headerlink" title="JVM运行内存的分类"></a>JVM运行内存的分类</h3><ul>
<li><strong>程序计数器</strong><ul>
<li>线程私有</li>
<li>当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址</li>
<li>如果正在执行的是native方法，则为空</li>
</ul>
</li>
<li><strong>虚拟机栈</strong><ul>
<li>线程私有</li>
<li>每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>用于存放<strong>局部变量表、操作栈、动态链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</li>
<li>生命周期与线程相同</li>
<li>为java方法服务</li>
</ul>
</li>
<li><strong>native方法栈</strong><ul>
<li>与java虚拟机栈相似</li>
<li>区别：为native方法服务</li>
</ul>
</li>
<li><strong>java堆</strong><ul>
<li>线程共享</li>
<li>JVM所管理的内存中最大的一块，在虚拟机启动时创建</li>
<li>唯一目的：<strong>存放对象实例、数组</strong></li>
<li>GC回收的主要区域</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>线程共享</li>
<li>存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li>
<li>回收目标：主要是常量池的回收和类型的卸载</li>
</ul>
</li>
</ul>
<h3 id="Java四大引用"><a href="#Java四大引用" class="headerlink" title="Java四大引用"></a>Java四大引用</h3><ul>
<li><strong>强引用</strong><ul>
<li>如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题</li>
<li>例子：Object obj = new Object();<ul>
<li>这里obj 就是引用，new Object() 对象实例存储在堆内存，obj引用的是对象实例的<strong>内存地址</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>软引用</strong><ul>
<li>可以和一个<strong>引用队列（ReferenceQueue)</strong> 联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中</li>
<li>用来描述可用但不是必须存活的对象；在内存溢出之前，虚拟机尝试对这些对象进行回收。如果回收之后内存还是不够才会出现内存溢出情况。</li>
</ul>
</li>
<li><strong>弱引用</strong><ul>
<li>与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期</li>
<li>被弱引用关联的对象只能生存到下一次垃圾回收发生之前。</li>
<li>只要垃圾回收机制在工作，无论内存是否足够，都会回收掉这部分对象。</li>
</ul>
</li>
<li><strong>虚引用</strong><ul>
<li>虚引用在任何时候都可能被垃圾回收器回收。一个对象是否被虚引用关联，完全不对其生存周期构成影响。</li>
<li><strong>主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。</strong></li>
<li><strong>必须</strong> 和引用队列 （ReferenceQueue）联合使用。</li>
<li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li>
<li>不能通过一个虚引用获取到一个对象实例</li>
</ul>
</li>
</ul>
<h2 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h2><p>Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。</p>
<p>GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。</p>
<p>程序员不用担心内存管理，GC会自动进行管理。</p>
<h3 id="GC标记对象的方法"><a href="#GC标记对象的方法" class="headerlink" title="GC标记对象的方法"></a>GC标记对象的方法</h3><ol>
<li><strong>引用计数法</strong><ul>
<li>给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示该对象可以被 GC 回收了，</li>
<li><strong>弊端：</strong> A-&gt;B,B-&gt;A,那么 AB 将永远不会被回收了。也就是<strong>引用有环</strong>的情况</li>
</ul>
</li>
<li><strong>根搜索算法(可达性算法) GC Roots Tracing</strong><ul>
<li>通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为<strong>引用链</strong>,当一个对象没有与任何的引用链相连的时候则该对象就可以被回收。</li>
<li>根搜索算法中不可达的对象并非“非死不可”,真正宣告一个对象死亡需要<strong>两次</strong>标记过程。</li>
<li>finalize()方法只会被调用一次</li>
<li><strong>GC回收的Roots包括：</strong><ul>
<li>java虚拟机栈中引用的对象<ul>
<li>eg: 方法里面定义这种局部变量 User user= new User();</li>
</ul>
</li>
<li>native方法栈中引用的对象</li>
<li>方法区中常量引用的对象<ul>
<li>eg: private static final  User user = new User();</li>
</ul>
</li>
<li>方法区中静态属性引用的对象<ul>
<li>eg: private static User user = new User();</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ol>
<li><strong>标记-清除</strong><ul>
<li>缺点：产生内存碎片</li>
</ul>
</li>
<li><strong>复制算法</strong><ul>
<li>按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉</li>
<li>缺点：内存缩小为原来的一半</li>
</ul>
</li>
<li><strong>标记-整理</strong><ul>
<li>标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</li>
<li>优点：解决了清除算法的内存碎片问题和复制算法的效率低下问题</li>
</ul>
</li>
<li><strong>分代收集算法</strong><ul>
<li>根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代。</li>
<li>新生代采用复制算法，老年代采用标记-整理算法</li>
</ul>
</li>
</ol>
<h3 id="Minor-GC-amp-Full-GC"><a href="#Minor-GC-amp-Full-GC" class="headerlink" title="Minor GC &amp; Full GC"></a>Minor GC &amp; Full GC</h3><ul>
<li>Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制回收算法</li>
<li>Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法/标记-整理算法</li>
</ul>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul>
<li><strong>结构</strong>（堆大小 = 新生代 + 老年代）<ul>
<li>新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（8 : 1 : 1）</li>
<li>老年代(2/3)(长时间存在的对象)</li>
</ul>
</li>
<li>一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC）<ul>
<li>如果survivor0可以放入，那么放入之后清除Eden区</li>
<li>如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中<ul>
<li>如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。</li>
<li>如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为<strong>分配担保（Full GC）</strong></li>
</ul>
</li>
</ul>
</li>
<li>大对象、长期存活的对象则直接进入老年代</li>
<li>动态对象年龄判定</li>
</ul>
<h3 id="GC垃圾收集器"><a href="#GC垃圾收集器" class="headerlink" title="GC垃圾收集器"></a>GC垃圾收集器</h3><ul>
<li>Serial New收集器：单线程，针对新生代的收集器，采用的是复制算法</li>
<li>Parallel New（并行）收集器：多线程，新生代采用复制算法，老年代采用标记整理</li>
<li>Parallel Scavenge（并行）收集器：多线程，针对新生代，采用复制算法</li>
<li>Serial Old（串行）收集器：单线程，新生代采用复制，老年代采用标记整理</li>
<li>Parallel Old（并行）收集器：多线程，针对老年代，标记整理</li>
<li>CMS收集器：基于标记-清除</li>
<li>G1收集器(JDK)：整体上是基于标记整理，局部采用复制</li>
<li>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理</li>
</ul>
<h3 id="如何减少GC次数？"><a href="#如何减少GC次数？" class="headerlink" title="如何减少GC次数？"></a>如何减少GC次数？</h3><ul>
<li>对象尽量不要显式设置为null</li>
<li>少用system.gc</li>
<li>少用静态变量</li>
<li>尽量使用 StringBuffer,而不用 String 来累加字符串</li>
<li>使用软引用类型</li>
</ul>
<h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><p>  虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ol>
<li><strong>加载过程</strong><ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ul>
</li>
<li><strong>验证过程</strong><ul>
<li>确保Class文件的字节流中包含的信息符合当前虚拟机的要求</li>
</ul>
</li>
<li><strong>准备过程</strong><ul>
<li>正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在<strong>方法区中</strong>进行分配</li>
</ul>
</li>
<li><strong>解析阶段</strong><ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程</li>
</ul>
</li>
<li><strong>初始化阶段</strong><ul>
<li>类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器方法的过程</li>
</ul>
</li>
<li><strong>使用阶段</strong></li>
<li><strong>卸载阶段</strong></li>
</ol>
<h3 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h3><ul>
<li>负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次</li>
<li><strong>Bootstrap ClassLoader:</strong> 启动类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现</li>
<li><strong>Extension ClassLoader:</strong> 扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的</li>
<li><strong>System ClassLoader:系统(应用)类加载器：</strong> 它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><ul>
<li><strong>工作原理</strong><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</li>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以 <em>避免类的重复加载</em></li>
<li>考虑到安全因素，java核心api中定义类型不会被随意替换<ul>
<li>eg:假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JAVA内存模型-JMM"><a href="#JAVA内存模型-JMM" class="headerlink" title="JAVA内存模型(JMM)"></a>JAVA内存模型(JMM)</h2><ul>
<li><p><strong>主要目标</strong></p>
<ul>
<li>定义程序中各个变量的访问规则</li>
</ul>
<p>线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</p>
</li>
<li><strong>先行发生原则happens-before</strong><ul>
<li>如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/数据结构和排序算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/数据结构和排序算法/" itemprop="url">数据结构和排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-12T11:15:02+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>直接插入排序</li>
<li>折半插入排序（二分法插入）</li>
<li>希尔排序：不稳定</li>
</ul>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>稳定，算法复杂度：O(n²)</strong></p>
<pre><code>public void insertionSort(int[] a) {
    for (int i = 1; i &lt; a.length; i++) {
        int temp = a[i];
        int j = i - 1;
        while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
    }
}
</code></pre><h3 id="折半插入排序（此处描述的是二分法查找算法）"><a href="#折半插入排序（此处描述的是二分法查找算法）" class="headerlink" title="折半插入排序（此处描述的是二分法查找算法）"></a>折半插入排序（此处描述的是二分法查找算法）</h3><p><strong>稳定，查找算法复杂度：O(logN)；排序算法复杂度：O(NlogN)</strong></p>
<p><strong>要求：1.存储在数组中（链表中不适合） 2.有序排列</strong></p>
<p>在算法中属于<code>分治算法</code></p>
<pre><code> //递归实现
 public int binarySearchRecursion(int[] array, int low, int high, int target) {
    if (low &gt; high)
        return -1;
    int mid = (low + high) / 2;
    if (target &lt; array[mid])
        return binarySearchRecursion(array, low, mid - 1, target);
    if (target &gt; array[mid])
        return binarySearchRecursion(array, mid + 1, high, target);
    return array[mid];
}

//非递归实现
public int binarySearch(int[] array, int low, int high, int target) {
    while (low &lt;= high) {
        int mid = (low + high) / 2;
        if (target &lt; array[mid])
            high = mid - 1;
        else if (target &gt; array[mid])
            low = mid + 1;
        else
            return mid;
    }
    return -1;
}
</code></pre><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul>
<li>冒泡排序</li>
<li>快速排序(不稳定)</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>稳定，算法复杂度：O(n²)；最好情况下O(n)</strong></p>
<pre><code>public void bubbleSort(int[] a) {
    for (int i = 0; i &lt; a.length; i++) {
        for (int j = 1; j &lt; a.length - i; j++) {
            if (a[j] &lt; a[j - 1]) {
                int temp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = temp;
            }
        }
    }
}
//算法还可以改进，从两头向中间逼近，可以加快速度
</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>不稳定，算法复杂度：O(NlogN)</strong></p>
<p>在所有同数量级的排序方法中，平均性能最好</p>
<pre><code>//递归实现
public void quickSortRecursion(int[] arr, int low, int high) {
    if (low &lt; high) {
        int pivot = partition(arr, low, high);
        quickSortRecursion(arr, low, pivot - 1);
        quickSortRecursion(arr, pivot + 1, high);
    }
}


private int partition(int[] arr, int low, int high) {
    int pivot = arr[low];
    while (low &lt; high) {
        while (low &lt; high &amp;&amp; arr[high] &gt; pivot) high--;
        arr[low] = arr[high];
        while (low &lt; high &amp;&amp; arr[low] &lt; pivot) low++;
        arr[high] = arr[low];

    }
    arr[low] = pivot;
    return low;
}

//非递归实现
public void quickSort(int[] arr, int low, int high) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    if (low &lt; high) {
        stack.push(high);
        stack.push(low);
        while (!stack.empty()) {
            int l = stack.pop();
            int r = stack.pop();
            int pivot = partition(arr, l, r);
            if (l &lt; pivot - 1) {
                stack.push(pivot - 1);
                stack.push(l);
            }
            if (r &gt; pivot + 1) {
                stack.push(r);
                stack.push(pivot + 1);
            }
        }
    }
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>直接选择排序：不稳定<ul>
<li>直接选择最小(最大)的记录与第一个记录交换位置，再对余下的n-1个进行同样操作</li>
<li>算法复杂度：O(n²)</li>
<li>存在重复做比较的情况</li>
</ul>
</li>
<li>锦标赛排序（树形）：稳定<ul>
<li>N个关键码两两比较，得到 n/2 个比较的优胜者(关键码小者)保留下来, 再对这 n/2个对象再进行关键码的两两比较, ……直至选出一个最小的关键码为止。</li>
<li>算法复杂度：O(NlogN)</li>
</ul>
</li>
<li>堆排序：不稳定<ul>
<li>算法复杂度：O(NlogN)</li>
</ul>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><pre><code>//堆排序
public void heapsort(int[] arr) {
    for (int i = arr.length / 2; i &gt;= 0; i--)
        adjustHeap(arr, i, arr.length);
    for (int i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i);
        adjustHeap(arr, 0, i);
    }
}

/** 构建最大堆的过程
 * @param arr 数组
 * @param i   需要构建堆的根节点的序号
 * @param n   数组长度
 ** /
public void adjustHeap(int[] arr, int i, int n) {
    int father;
    int child;
    for (father = arr[i]; leftChild(i) &lt; n; i = child) {
        child = leftChild(i);
        // 如果左子树小于右子树，则需要比较右子树和父节点
        if (child != n - 1 &amp;&amp; arr[child] &lt; arr[child + 1])
            child++;//序号+1，指向右子树
        // 如果父节点小于孩子结点，则需要交换
        if (father &lt; arr[child]) {
            arr[i] = arr[child];
        } else
            break;//是最大堆，无需破坏
    }
    arr[i] = father;
}

private int leftChild(int i) {
    return 2 * i + 1;
}

private void swap(int[] arr, int index1, int index2) {
    int tmp = arr[index1];
    arr[index1] = arr[index2];
    arr[index2] = tmp;
}  
</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>稳定，算法复杂度：O(NlogN)</strong></p>
<p>在算法中属于<code>分治算法</code></p>
<pre><code>//递归
public void MergeSort(int[] arr, int left, int right) {
    int mid = (left + right) / 2;
    if (left &lt; right){
        MergeSort(arr, left, mid);
        MergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}


//merge函数实际上是将两个有序数组合并成一个有序数组
//因为数组有序，合并很简单，只要维护几个指针就可以了
private void merge(int[] arr, int left, int mid, int right) {
    //temp数组用于暂存合并的结果
    int[] temp = new int[right - left + 1];
    //左半边的指针
    int head1 = left;
    //右半边的指针
    int head2 = mid+1;
    //合并后数组的指针
    int index = 0;

    //将记录由小到大地放进temp数组
    for(; head1 &lt;= mid &amp;&amp; head2 &lt;= right; index++) {
        if(arr[head1] &lt; arr[head2])
            temp[index] = arr[head1++];
        else
            temp[index] = arr[head2++];
    }

    //接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中
    while(head1 &lt;= mid)
        temp[index++] = arr[head1++];

    while(head2 &lt;= right)
        temp[index++] = arr[head2++];

    //将temp数组中的元素写入到待排数组中
    for(int i = 0; i &lt; temp.length; i++)
        arr[left + i] = temp[i];
}

//非递归
private void MergeSort(int[] arr) {
    int len = arr.length;
    int step = 1; //每一个区间的长度，1,2,4,8...
    while (step &lt;= len) {
        int offset = 2 * step;
        for (int i = 0; i &lt; len; i += offset)
            merge(arr, i, Math.min(i + step - 1, len - 1), Math.min(i + offset - 1, len - 1));
        step = offset;
    }
}
</code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li>桶排序：稳定</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/24/算法整理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/算法整理/" itemprop="url">算法整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-24T14:15:04+08:00">
                2018-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="一-穷举法"><a href="#一-穷举法" class="headerlink" title="(一) 穷举法"></a>(一) 穷举法</h2><h2 id="二-贪婪算法"><a href="#二-贪婪算法" class="headerlink" title="(二) 贪婪算法"></a>(二) 贪婪算法</h2><p>在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的<strong>局部最优解</strong>。</p>
<p>贪婪算法不能保证全局最优，所以使用贪心算法的前提是，局部最优策略能导致全局最优解。同时贪心算法必须满足无后效性，即某个状态以后的状态不会影响以前的状态。</p>
<h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>局部最优策略能导致全局最优解</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ol>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每一子问题求解，得到子问题的局部最优解</li>
<li>把局部最优解合成原来问题的一个解</li>
</ol>
<h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><ol>
<li>霍夫曼编码</li>
<li>最小生成树</li>
<li>0/1背包问题</li>
</ol>
<h2 id="三-动态规划"><a href="#三-动态规划" class="headerlink" title="(三) 动态规划"></a>(三) 动态规划</h2><p> 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的。</p>
<p> 与分治法最大的差别是：<code>适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</code></p>
<h3 id="适用情况-1"><a href="#适用情况-1" class="headerlink" title="适用情况"></a>适用情况</h3><ol>
<li>最优化原理：问题的最优解所包含的子问题的解也是最优的</li>
<li>无后效性：某阶段状态一旦确定，就不受这个状态以后决策的影响</li>
<li>有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。</li>
</ol>
<h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p><em>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</em></p>
<ol>
<li>划分：划分后的阶段一定要是有序的或者是可排序的</li>
<li>确定状态和状态变量：要满足无后效性</li>
<li>确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态</li>
<li>寻找边界条件</li>
</ol>
<h3 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h3><ol>
<li>N级台阶问题</li>
<li>最长递增子序列</li>
</ol>
<h2 id="四-分治算法"><a href="#四-分治算法" class="headerlink" title="(四) 分治算法"></a>(四) 分治算法</h2><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<h3 id="适用情况-2"><a href="#适用情况-2" class="headerlink" title="适用情况"></a>适用情况</h3><ol>
<li>问题的复杂性随问题的规模递增</li>
<li>最优子结构性质</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解<ul>
<li>如果不满足第三条，可以用贪心算法Or动态规划算法</li>
</ul>
</li>
<li>子问题之间相互独立</li>
</ol>
<h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><p><em>分解-解决-合并</em></p>
<p>###经典问题</p>
<ol>
<li>快速排序</li>
<li>归并排序</li>
<li>二分查找</li>
</ol>
<h2 id="五-回溯法"><a href="#五-回溯法" class="headerlink" title="(五) 回溯法"></a>(五) 回溯法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p><code>**深度优先搜索策略**</code></p>
<h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ol>
<li>确定问题的解空间</li>
<li>确定节点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</li>
</ol>
<h2 id="六-分支界限算法"><a href="#六-分支界限算法" class="headerlink" title="(六) 分支界限算法"></a>(六) 分支界限算法</h2><p>回溯法的求解目标是找出T中满足约束条件的<em>所有解</em>，而分支限界法的求解目标则是找出<em>满足约束条件的一个解</em>，或是在满足约束条件的解中找出使某一目标函数值达到<em>极大或极小的解</em>，即<em>在某种意义下的最优解</em>。</p>
<p><code>**广度优先搜索策略**</code></p>
<h3 id="分支搜索算法"><a href="#分支搜索算法" class="headerlink" title="分支搜索算法"></a>分支搜索算法</h3><ol>
<li>FIFO搜索</li>
<li>LIFO搜索</li>
<li>优先队列式搜索</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/微服务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cao Shuyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alpaca's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/微服务/" itemprop="url">微服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-20T15:49:58+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p><a href="http://dockone.io/article/3687" target="_blank" rel="noopener">http://dockone.io/article/3687</a></p>
<p><a href="https://www.kancloud.cn/good-rain/micro-services/248952" target="_blank" rel="noopener">https://www.kancloud.cn/good-rain/micro-services/248952</a></p>
<h2 id="API网关比较"><a href="#API网关比较" class="headerlink" title="API网关比较"></a>API网关比较</h2><h4 id="NGINX-vs-ZUUL-vs-Spring-Cloud-Gateway-vs-Linkerd"><a href="#NGINX-vs-ZUUL-vs-Spring-Cloud-Gateway-vs-Linkerd" class="headerlink" title="NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerd"></a>NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerd</h4><p><a href="https://juejin.im/entry/5ad408de6fb9a028cc61af94" target="_blank" rel="noopener">https://juejin.im/entry/5ad408de6fb9a028cc61af94</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Cao Shuyue</p>
              <p class="site-description motion-element" itemprop="description">用来记录一些知识~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cao Shuyue</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
